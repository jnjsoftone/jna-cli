"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=exports,r={get cloneRepo(){return f},get copyRepo(){return y},get createProjectCard(){return H},get createProjectColumn(){return A},get createRemoteRepo(){return d},get createRepoIssue(){return j},get createRepoProject(){return P},get deleteRemoteRepo(){return m},get dispatchWorkflow(){return S},get findAllRepos(){return p},get findAllUsers(){return T},get findGithubAccount(){return g},get initLocalRepo(){return h},get initRepo(){return R},get listRepoIssues(){return E},get listRepoProjects(){return k},get listRepoWorkflows(){return O},get listWorkflowRuns(){return G},get makeRepo(){return _},get pullRepo(){return v},get pushRepo(){return w},get removeRepo(){return b},get setLocalConfig(){return $},get syncRepo(){return N},get updateRepoIssue(){return I}};for(var o in r)Object.defineProperty(t,o,{enumerable:!0,get:Object.getOwnPropertyDescriptor(r,o).get});const n=(e=require("path"))&&e.__esModule?e:{default:e},s=require("child_process"),i=require("jnu-abc"),c=require("jnu-cloud"),a=require("./cli.js"),l=require("./env.js"),u=(e,t={})=>{let{wait:r=0,msg:o="",echo:n=!0}=t;n&&(o=o||e,console.log(`Command: ${o}`));try{(0,s.execSync)(e),(0,i.sleep)(r)}catch(e){console.log("EXEC Error: ",e)}},g=async(e,t="github")=>{let{ENV_GITHUB_OWNER:r,ENV_GITHUB_REPO:o,ENV_GITHUB_TOKEN:n}=process.env,s={owner:process.env.ENV_GITHUB_OWNER||"",repo:process.env.ENV_GITHUB_REPO||"",token:process.env.ENV_GITHUB_TOKEN||""};try{if("local"===t){let t=await (0,i.loadJson)(`${l.localEnvRoot}/Apis/github.json`),r=t?.[e];return r&&(r.userName=r.userName??e),r}if("github"===t){let t=await (0,c.readJsonFromGithub)("Apis/github.json",s),r=t?.[e];return r&&(r.userName=r.userName??e),r}return}catch(e){if(console.error("GitHub 계정 정보를 가져오는 중 오류가 발생했습니다:",e),process.env.ENV_GITHUB_OWNER&&process.env.ENV_GITHUB_TOKEN)return{userName:process.env.ENV_GITHUB_OWNER,fullName:process.env.ENV_GITHUB_OWNER,email:process.env.ENV_GITHUB_EMAIL??"",token:process.env.ENV_GITHUB_TOKEN};return}},p=async e=>{try{return(await e.rest.repos.listForAuthenticatedUser({per_page:100,sort:"updated"})).data}catch(e){throw e}},d=(e,t)=>{console.log("####@@@@@ createRemoteRepo options: ",t);let{name:r,description:o,isPrivate:n}=t;return e.rest.repos.createForAuthenticatedUser({name:r,description:o,private:n,auto_init:!0})},m=(e,t,r)=>{let{name:o}=t;return console.log(`### deleteRemoteRepo: ${o}`),e.rest.repos.delete({owner:r.userName,repo:o})},$=(e,t,r)=>{let o=`cd ${r} && git config user.name "${t.fullName}"`;u(o+=` && git config user.email "${t.email}" && git remote set-url origin https://${t.token}@github.com/${t.userName}/${e.name}.git`)},h=async(e,t,r)=>{let{name:o}=e,{fullName:n,email:s,token:i,userName:c}=t,a="";u(`cd ${r} && git init && git config --global --add safe.directory ${r}`,{wait:1});try{u(`cd ${r} && git branch -m master main`,{wait:2})}catch(e){console.log("####@@@@@===== error: ",e)}a=`cd ${r} && git config user.name "${n}" && git config user.email "${s}" && git remote add origin https://${i}@github.com/${c}/${o}.git`;let l=e.description||"Initial commit";u(a+=` && git add . && git commit -m "${l}"`,{wait:10})},f=(e,t,r)=>{u(`cd ${n.default.dirname(r)} && git clone https://${t.token}@github.com/${t.userName}/${e.name}.git`)},R=(e,t,r,o)=>{let n=`xgit -e createRemoteRepo -u ${r.userName} -n ${t.name} -d "${t.description}" -p ${t.isPrivate}`;u(n,{wait:10,msg:`initRepo ${n}`}),f(t,r,o),(0,i.sleep)(5),$(t,r,o)},y=(e,t,r)=>{f(e,t,r),(0,i.sleep)(10),$(e,t,r)},w=(e,t,r)=>{if((0,s.execSync)(`cd ${r} && git status --porcelain`,{encoding:"utf8"}).length>0){let t=e.description||"Initial commit",o=`cd ${r} && git add . && git commit -m "${t}"`;u(o,{msg:`pushRepo ${o}`})}let o=(0,s.execSync)(`cd ${r} && git branch`);console.log(`#### pushRepo branches: ${o}`),o.includes("main")?u(`cd ${r} && git push -u origin main --force`):o.includes("master")?u(`cd ${r} && git push -u origin master --force`):console.log("main 또는 master 브랜치가 없습니다.")},_=(e,t,r,o)=>{console.log("####@@@@@===== makeRepo options: ",JSON.stringify(t)),u(`xgit -e createRemoteRepo -u ${r.userName} -n ${t.name} -d "${t.description}" -p ${t.isPrivate}`,{wait:10}),console.log(`=================== initLocalRepo: ${o}`),h(t,r,o),(0,i.sleep)(15),console.log(`=================== pushRepo: ${o}`),w(t,r,o)},b=(e,t,r,o)=>{m(e,t,r),(0,i.sleep)(10);let{name:s}=t;if("win"===a.PLATFORM)try{let e=`cd ${n.default.dirname(o)}`;u(e);let t=`rmdir /s /q ${s}`;u(t)}catch(e){console.error("Failed to remove directory:",e);try{let e=`rd /s /q "${o}"`;u(e)}catch(e){console.error("Alternative removal also failed:",e)}}else u(`cd ${n.default.dirname(o)} && rm -rf ${s}`)},v=(e,t,r)=>{try{let e=(0,s.execSync)(`cd ${r} && git rev-parse --abbrev-ref HEAD`,{encoding:"utf8"}).trim();console.log(`📥 Pulling latest changes from ${e} branch...`);let t=`cd ${r} && git pull origin ${e}`;u(t,{msg:`pullRepo: ${t}`}),console.log("✅ Pull completed successfully!")}catch(e){throw console.error("❌ Pull failed:",e),e}},N=(e,t,r)=>{try{console.log("🔄 Starting repository synchronization...");let t=(0,s.execSync)(`cd ${r} && git rev-parse --abbrev-ref HEAD`,{encoding:"utf8"}).trim();if(console.log(`📍 Current branch: ${t}`),(0,s.execSync)(`cd ${r} && git status --porcelain`,{encoding:"utf8"}).length>0){console.log("📝 Local changes detected, committing...");let t=e.description||`Auto-sync: ${new Date().toISOString()}`,o=`cd ${r} && git add . && git commit -m "${t}"`;u(o,{msg:`syncRepo commit: ${o}`})}else console.log("📋 No local changes to commit");console.log("📥 Fetching from remote..."),u(`cd ${r} && git fetch origin ${t}`,{msg:"syncRepo fetch"});try{let e=(0,s.execSync)(`cd ${r} && git rev-list --count HEAD..origin/${t}`,{encoding:"utf8"}).trim(),o=(0,s.execSync)(`cd ${r} && git rev-list --count origin/${t}..HEAD`,{encoding:"utf8"}).trim();console.log(`📊 Repository status: ${o} commits ahead, ${e} commits behind`),parseInt(e)>0&&(console.log("📥 Pulling remote changes..."),u(`cd ${r} && git pull origin ${t}`,{msg:"syncRepo pull"})),parseInt(o)>0&&(console.log("📤 Pushing local changes..."),u(`cd ${r} && git push origin ${t}`,{msg:"syncRepo push"})),0===parseInt(e)&&0===parseInt(o)?console.log("✅ Repository is already up to date!"):console.log("✅ Synchronization completed successfully!")}catch(e){console.log("📤 Pushing to remote (first time)..."),u(`cd ${r} && git push -u origin ${t}`,{msg:"syncRepo initial push"}),console.log("✅ Initial push completed successfully!")}}catch(e){throw console.error("❌ Sync failed:",e),e}},E=async(e,t)=>{let{owner:r,repo:o,state:n="open",labels:s,assignee:i,perPage:c=30,page:a=1}=t;return(await e.rest.issues.listForRepo({owner:r,repo:o,state:n,labels:s&&s.length>0?s.join(","):void 0,assignee:i,per_page:c,page:a})).data},j=async(e,t)=>{let{owner:r,repo:o,title:n,body:s,labels:i,assignees:c,milestone:a}=t;return(await e.rest.issues.create({owner:r,repo:o,title:n,body:s,labels:i,assignees:c,milestone:a})).data},I=async(e,t)=>{let{owner:r,repo:o,issueNumber:n,title:s,body:i,state:c,labels:a,assignees:l,milestone:u}=t;return(await e.rest.issues.update({owner:r,repo:o,issue_number:n,title:s,body:i,state:c,labels:a,assignees:l,milestone:u})).data},k=async(e,t)=>{let{owner:r,repo:o,state:n="open",perPage:s=30}=t;return(await e.rest.projects.listForRepo({owner:r,repo:o,state:n,per_page:s})).data},P=async(e,t)=>{let{owner:r,repo:o,name:n,body:s}=t;return(await e.rest.projects.createForRepo({owner:r,repo:o,name:n,body:s})).data},A=async(e,t)=>{let{projectId:r,name:o}=t;return(await e.rest.projects.createColumn({project_id:r,name:o})).data},H=async(e,t)=>{let{columnId:r,note:o,contentId:n,contentType:s}=t;if(o)return(await e.rest.projects.createCard({column_id:r,note:o})).data;if(!n||!s)throw Error("Project card requires either a note or a content reference");return(await e.rest.projects.createCard({column_id:r,content_id:n,content_type:s})).data},O=async(e,t)=>{let{owner:r,repo:o,perPage:n=30,page:s=1}=t;return(await e.rest.actions.listRepoWorkflows({owner:r,repo:o,per_page:n,page:s})).data.workflows},G=async(e,t)=>{let{owner:r,repo:o,workflowId:n,branch:s,status:i,perPage:c=30,page:a=1}=t;return n?(await e.rest.actions.listWorkflowRuns({owner:r,repo:o,workflow_id:n,branch:s,status:i,per_page:c,page:a})).data.workflow_runs:(await e.rest.actions.listWorkflowRunsForRepo({owner:r,repo:o,branch:s,status:i,per_page:c,page:a})).data.workflow_runs},S=async(e,t)=>{let{owner:r,repo:o,workflowId:n,ref:s,inputs:i}=t;await e.rest.actions.createWorkflowDispatch({owner:r,repo:o,workflow_id:n,ref:s,inputs:i})},T=async(e="github")=>{try{if("local"===e)return await (0,i.loadJson)(`${l.localEnvRoot}/Apis/github.json`);if("github"===e)return await (0,c.readJsonFromGithub)("Apis/github.json",l.githubEnv);return}catch(e){console.error("GitHub 사용자 목록을 가져오는 중 오류가 발생했습니다:",e);return}};