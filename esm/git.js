import e from"path";import{execSync as t}from"child_process";import{sleep as o,loadJson as r}from"jnu-abc";import{readJsonFromGithub as i}from"jnu-cloud";import{PLATFORM as s}from"./cli.js";import{githubEnv as n,localEnvRoot as c}from"./env.js";let a=(e,r={})=>{let{wait:i=0,msg:s="",echo:n=!0}=r;n&&(s=s||e,console.log(`Command: ${s}`));try{t(e),o(i)}catch(e){console.log("EXEC Error: ",e)}},l=async(e,t="github")=>{let{ENV_GITHUB_OWNER:o,ENV_GITHUB_REPO:s,ENV_GITHUB_TOKEN:n}=process.env,a={owner:process.env.ENV_GITHUB_OWNER||"",repo:process.env.ENV_GITHUB_REPO||"",token:process.env.ENV_GITHUB_TOKEN||""};try{if("local"===t){let t=await r(`${c}/Apis/github.json`);return t?.[e]}if("github"===t){let t=await i("Apis/github.json",a);return t?.[e]}return}catch(e){if(console.error("GitHub 계정 정보를 가져오는 중 오류가 발생했습니다:",e),process.env.ENV_GITHUB_OWNER&&process.env.ENV_GITHUB_TOKEN)return{userName:process.env.ENV_GITHUB_OWNER,fullName:process.env.ENV_GITHUB_OWNER,email:process.env.ENV_GITHUB_EMAIL??"",token:process.env.ENV_GITHUB_TOKEN};return}},p=async e=>{try{return(await e.rest.repos.listForAuthenticatedUser({per_page:100,sort:"updated"})).data}catch(e){throw e}},u=(e,t)=>{console.log("####@@@@@ createRemoteRepo options: ",t);let{name:o,description:r,isPrivate:i}=t;return e.rest.repos.createForAuthenticatedUser({name:o,description:r,private:i,auto_init:!0})},g=(e,t,o)=>{let{name:r}=t;return console.log(`### deleteRemoteRepo: ${r}`),e.rest.repos.delete({owner:o.userName,repo:r})},m=(e,t,o)=>{let r=`cd ${o} && git config user.name "${t.fullName}"`;a(r+=` && git config user.email "${t.email}" && git remote set-url origin https://${t.token}@github.com/${t.userName}/${e.name}.git`)},d=async(e,t,o)=>{let{name:r}=e,{fullName:i,email:s,token:n,userName:c}=t,l="";a(`cd ${o} && git init && git config --global --add safe.directory ${o}`,{wait:1});try{a(`cd ${o} && git branch -m master main`,{wait:2})}catch(e){console.log("####@@@@@===== error: ",e)}l=`cd ${o} && git config user.name "${i}" && git config user.email "${s}" && git remote add origin https://${n}@github.com/${c}/${r}.git`;let p=e.description||"Initial commit";a(l+=` && git add . && git commit -m "${p}"`,{wait:10})},$=(t,o,r)=>{a(`cd ${e.dirname(r)} && git clone https://${o.token}@github.com/${o.userName}/${t.name}.git`)},h=(e,t,r,i)=>{let s=`xgit -e createRemoteRepo -u ${r.userName} -n ${t.name} -d "${t.description}" -p ${t.isPrivate}`;a(s,{wait:10,msg:`initRepo ${s}`}),$(t,r,i),o(5),m(t,r,i)},f=(e,t,r)=>{$(e,t,r),o(10),m(e,t,r)},R=(e,o,r)=>{if(t(`cd ${r} && git status --porcelain`,{encoding:"utf8"}).length>0){let t=e.description||"Initial commit",o=`cd ${r} && git add . && git commit -m "${t}"`;a(o,{msg:`pushRepo ${o}`})}let i=t(`cd ${r} && git branch`);console.log(`#### pushRepo branches: ${i}`),i.includes("main")?a(`cd ${r} && git push -u origin main --force`):i.includes("master")?a(`cd ${r} && git push -u origin master --force`):console.log("main 또는 master 브랜치가 없습니다.")},w=(e,t,r,i)=>{console.log("####@@@@@===== makeRepo options: ",JSON.stringify(t)),a(`xgit -e createRemoteRepo -u ${r.userName} -n ${t.name} -d "${t.description}" -p ${t.isPrivate}`,{wait:10}),console.log(`=================== initLocalRepo: ${i}`),d(t,r,i),o(15),console.log(`=================== pushRepo: ${i}`),R(t,r,i)},y=(t,r,i,n)=>{g(t,r,i),o(10);let{name:c}=r;if("win"===s)try{let t=`cd ${e.dirname(n)}`;a(t);let o=`rmdir /s /q ${c}`;a(o)}catch(e){console.error("Failed to remove directory:",e);try{let e=`rd /s /q "${n}"`;a(e)}catch(e){console.error("Alternative removal also failed:",e)}}else a(`cd ${e.dirname(n)} && rm -rf ${c}`)},_=(e,o,r)=>{try{let e=t(`cd ${r} && git rev-parse --abbrev-ref HEAD`,{encoding:"utf8"}).trim();console.log(`📥 Pulling latest changes from ${e} branch...`);let o=`cd ${r} && git pull origin ${e}`;a(o,{msg:`pullRepo: ${o}`}),console.log("✅ Pull completed successfully!")}catch(e){throw console.error("❌ Pull failed:",e),e}},b=(e,o,r)=>{try{console.log("🔄 Starting repository synchronization...");let o=t(`cd ${r} && git rev-parse --abbrev-ref HEAD`,{encoding:"utf8"}).trim();if(console.log(`📍 Current branch: ${o}`),t(`cd ${r} && git status --porcelain`,{encoding:"utf8"}).length>0){console.log("📝 Local changes detected, committing...");let t=e.description||`Auto-sync: ${new Date().toISOString()}`,o=`cd ${r} && git add . && git commit -m "${t}"`;a(o,{msg:`syncRepo commit: ${o}`})}else console.log("📋 No local changes to commit");console.log("📥 Fetching from remote..."),a(`cd ${r} && git fetch origin ${o}`,{msg:"syncRepo fetch"});try{let e=t(`cd ${r} && git rev-list --count HEAD..origin/${o}`,{encoding:"utf8"}).trim(),i=t(`cd ${r} && git rev-list --count origin/${o}..HEAD`,{encoding:"utf8"}).trim();console.log(`📊 Repository status: ${i} commits ahead, ${e} commits behind`),parseInt(e)>0&&(console.log("📥 Pulling remote changes..."),a(`cd ${r} && git pull origin ${o}`,{msg:"syncRepo pull"})),parseInt(i)>0&&(console.log("📤 Pushing local changes..."),a(`cd ${r} && git push origin ${o}`,{msg:"syncRepo push"})),0===parseInt(e)&&0===parseInt(i)?console.log("✅ Repository is already up to date!"):console.log("✅ Synchronization completed successfully!")}catch(e){console.log("📤 Pushing to remote (first time)..."),a(`cd ${r} && git push -u origin ${o}`,{msg:"syncRepo initial push"}),console.log("✅ Initial push completed successfully!")}}catch(e){throw console.error("❌ Sync failed:",e),e}},E=async(e,t)=>{let{owner:o,repo:r,state:i="open",labels:s,assignee:n,perPage:c=30,page:a=1}=t;return(await e.rest.issues.listForRepo({owner:o,repo:r,state:i,labels:s&&s.length>0?s.join(","):void 0,assignee:n,per_page:c,page:a})).data},N=async(e,t)=>{let{owner:o,repo:r,title:i,body:s,labels:n,assignees:c,milestone:a}=t;return(await e.rest.issues.create({owner:o,repo:r,title:i,body:s,labels:n,assignees:c,milestone:a})).data},v=async(e,t)=>{let{owner:o,repo:r,issueNumber:i,title:s,body:n,state:c,labels:a,assignees:l,milestone:p}=t;return(await e.rest.issues.update({owner:o,repo:r,issue_number:i,title:s,body:n,state:c,labels:a,assignees:l,milestone:p})).data},I=async(e,t)=>{let{owner:o,repo:r,state:i="open",perPage:s=30}=t;return(await e.rest.projects.listForRepo({owner:o,repo:r,state:i,per_page:s})).data},j=async(e,t)=>{let{owner:o,repo:r,name:i,body:s}=t;return(await e.rest.projects.createForRepo({owner:o,repo:r,name:i,body:s})).data},k=async(e,t)=>{let{projectId:o,name:r}=t;return(await e.rest.projects.createColumn({project_id:o,name:r})).data},A=async(e,t)=>{let{columnId:o,note:r,contentId:i,contentType:s}=t;if(r)return(await e.rest.projects.createCard({column_id:o,note:r})).data;if(!i||!s)throw Error("Project card requires either a note or a content reference");return(await e.rest.projects.createCard({column_id:o,content_id:i,content_type:s})).data},H=async(e,t)=>{let{owner:o,repo:r,perPage:i=30,page:s=1}=t;return(await e.rest.actions.listRepoWorkflows({owner:o,repo:r,per_page:i,page:s})).data.workflows},P=async(e,t)=>{let{owner:o,repo:r,workflowId:i,branch:s,status:n,perPage:c=30,page:a=1}=t;return i?(await e.rest.actions.listWorkflowRuns({owner:o,repo:r,workflow_id:i,branch:s,status:n,per_page:c,page:a})).data.workflow_runs:(await e.rest.actions.listWorkflowRunsForRepo({owner:o,repo:r,branch:s,status:n,per_page:c,page:a})).data.workflow_runs},G=async(e,t)=>{let{owner:o,repo:r,workflowId:i,ref:s,inputs:n}=t;await e.rest.actions.createWorkflowDispatch({owner:o,repo:r,workflow_id:i,ref:s,inputs:n})},T=async(e="github")=>{try{if("local"===e)return await r(`${c}/Apis/github.json`);if("github"===e)return await i("Apis/github.json",n);return}catch(e){console.error("GitHub 사용자 목록을 가져오는 중 오류가 발생했습니다:",e);return}};export{l as findGithubAccount,T as findAllUsers,p as findAllRepos,u as createRemoteRepo,g as deleteRemoteRepo,$ as cloneRepo,m as setLocalConfig,d as initLocalRepo,h as initRepo,f as copyRepo,R as pushRepo,w as makeRepo,y as removeRepo,_ as pullRepo,b as syncRepo,E as listRepoIssues,N as createRepoIssue,v as updateRepoIssue,I as listRepoProjects,j as createRepoProject,k as createProjectColumn,A as createProjectCard,H as listRepoWorkflows,P as listWorkflowRuns,G as dispatchWorkflow};